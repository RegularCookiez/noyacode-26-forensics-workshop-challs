# Solution

We are given the image file `z-bit.png`.

---

Given the challenge topic and hints about something hidden in the bits, we should expect to use zsteg.

In particular, zsteg is an LSB steganalysis tool that takes in PNG/BMP files.

---

First, navigate to your Downloads folder on your Linux terminal for file access using cd.

For example, on Windows, you could run `cd /mnt/c/Users/your_username/Downloads`.

Next, to run zsteg on `z-bit.png`, you would enter `zsteg z-bit.png`.

Doing so will reveal the following output:

```
imagedata           .. file: Microsoft Works 1-3 (DOS) or 2 (Windows) document
b1,r,lsb,xy         .. text: "Ta444k~in-~~g~-~t-hhhhee~-~1~e44~sttt--~~ssss~ii~ggnnnifffii~~~c4---n7~~bbiits~-0-f-----tt--h1~~~ii~sss~~aa~~s~~~c~iiiiireeevvvv~~ee~~~allss~~--t--hhheeff1144gg~~iin-binaaaaary"
b2,r,msb,xy         .. text: "}W}W}W}W}"
b3,rgb,msb,xy       .. file: AIX core file fulldump 64-bit
b4,bgr,msb,xy       .. file: MPEG ADTS, layer I, v2, Monaural
```

---

In particular, notice this long string:

```
b1,r,lsb,xy         .. text: "Ta444k~in-~~g~-~t-hhhhee~-~1~e44~sttt--~~ssss~ii~ggnnnifffii~~~c4---n7~~bbiits~-0-f-----tt--h1~~~ii~sss~~aa~~s~~~c~iiiiireeevvvv~~ee~~~allss~~--t--hhheeff1144gg~~iin-binaaaaary"
```

If you examine it, it spells out a sentence in a mix of Leetspeak/letters!

With some manual parsing, you can determine that it says:

> Taking the least significant bits of this ASCII reveals the flag in binary

This suggests that we have to copy this ASCII and take its binary.

---

To find the binary of this ASCII, we can copy it and paste the original ASCII in a binary converter.

One online website you can use for this is https://www.rapidtables.com/convert/number/ascii-to-binary.html.

This converts `Ta444k~in-~~g~-~t-hhhhee~-~1~e44~sttt--~~ssss~ii~ggnnnifffii~~~c4---n7~~bbiits~-0-f-----tt--h1~~~ii~sss~~aa~~s~~~c~iiiiireeevvvv~~ee~~~allss~~--t--hhheeff1144gg~~iin-binaaaaary` into:

```
01010100 01100001 00110100 00110100 00110100 01101011 01111110 01101001 01101110 00101101 01111110 01111110 01100111 01111110 00101101 01111110 01110100 00101101 01101000 01101000 01101000 01101000 01100101 01100101 01111110 00101101 01111110 00110001 01111110 01100101 00110100 00110100 01111110 01110011 01110100 01110100 01110100 00101101 00101101 01111110 01111110 01110011 01110011 01110011 01110011 01111110 01101001 01101001 01111110 01100111 01100111 01101110 01101110 01101110 01101001 01100110 01100110 01100110 01101001 01101001 01111110 01111110 01111110 01100011 00110100 00101101 00101101 00101101 01101110 00110111 01111110 01111110 01100010 01100010 01101001 01101001 01110100 01110011 01111110 00101101 00110000 00101101 01100110 00101101 00101101 00101101 00101101 00101101 01110100 01110100 00101101 00101101 01101000 00110001 01111110 01111110 01111110 01101001 01101001 01111110 01110011 01110011 01110011 01111110 01111110 01100001 01100001 01111110 01111110 01110011 01111110 01111110 01111110 01100011 01111110 01101001 01101001 01101001 01101001 01101001 01110010 01100101 01100101 01100101 01110110 01110110 01110110 01110110 01111110 01111110 01100101 01100101 01111110 01111110 01111110 01100001 01101100 01101100 01110011 01110011 01111110 01111110 00101101 00101101 01110100 00101101 00101101 01101000 01101000 01101000 01100101 01100101 01100110 01100110 00110001 00110001 00110100 00110100 01100111 01100111 01111110 01111110 01101001 01101001 01101110 00101101 01100010 01101001 01101110 01100001 01100001 01100001 01100001 01100001 01110010 01111001
```

Now, the previous text we found suggests taking the least significant bits of the ASCII.

If you recall, the least significant bit of a byte is the rightmost digit.

Therefore, we take the rightmost digit from each byte, and append them to form a new binary string.

---

To append this binary string, you can of course do it manually, though it would take quite long.

I would either suggest you prompt AI to automatically do it, or even code a basic script to extract the binary.

Below is a sample Python script I coded to extract the LSBs from the binary and append them to form a new binary string:

```

binary = "01010100 01100001 00110100 00110100 00110100 01101011 01111110 01101001 01101110 00101101 01111110 01111110 01100111 01111110 00101101 01111110 01110100 00101101 01101000 01101000 01101000 01101000 01100101 01100101 01111110 00101101 01111110 00110001 01111110 01100101 00110100 00110100 01111110 01110011 01110100 01110100 01110100 00101101 00101101 01111110 01111110 01110011 01110011 01110011 01110011 01111110 01101001 01101001 01111110 01100111 01100111 01101110 01101110 01101110 01101001 01100110 01100110 01100110 01101001 01101001 01111110 01111110 01111110 01100011 00110100 00101101 00101101 00101101 01101110 00110111 01111110 01111110 01100010 01100010 01101001 01101001 01110100 01110011 01111110 00101101 00110000 00101101 01100110 00101101 00101101 00101101 00101101 00101101 01110100 01110100 00101101 00101101 01101000 00110001 01111110 01111110 01111110 01101001 01101001 01111110 01110011 01110011 01110011 01111110 01111110 01100001 01100001 01111110 01111110 01110011 01111110 01111110 01111110 01100011 01111110 01101001 01101001 01101001 01101001 01101001 01110010 01100101 01100101 01100101 01110110 01110110 01110110 01110110 01111110 01111110 01100101 01100101 01111110 01111110 01111110 01100001 01101100 01101100 01110011 01110011 01111110 01111110 00101101 00101101 01110100 00101101 00101101 01101000 01101000 01101000 01100101 01100101 01100110 01100110 00110001 00110001 00110100 00110100 01100111 01100111 01111110 01111110 01101001 01101001 01101110 00101101 01100010 01101001 01101110 01100001 01100001 01100001 01100001 01100001 01110010 01111001"

#Take the binary string and split it into a list of each byte
binary_strings = binary.split()

#Define the empty new binary string and a length counter (to keep track of every 8 bits/1 byte)
new_binary = ""
length_counter = 0

for x in binary_strings:

    #Appends the rightmost bit to the new binary
    new_binary += x[7:]
    length_counter = (length_counter + 1) % 8

    #Adds a space if 8 bits has been added
    if length_counter == 0:
        new_binary += " "

#Print the new binary string
print(new_binary)
```

Running this Python file produces the new binary string:

```
01000101 01001010 01000011 01010100 01000110 01111011 01100010 00110001 01110100 00110101 01011111 00110100 01101110 01100100 01011111 01110000 00110001 00110011 01100011 00110011 00110101 01111101
```

Finally, by converting the binary to ASCII on an online converter like https://www.rapidtables.com/convert/number/binary-to-ascii.html, we get the flag:

`EJCTF{b1t5_4nd_p13c35}`
